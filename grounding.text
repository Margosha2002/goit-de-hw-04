Частина 1: 5 Jobs

Що відбувається:
Код виконує такі кроки:
- Завантаження CSV (spark.read.csv()).
- Перерозподіл даних (repartition).
- Фільтрація (where).
- Групування (groupBy і count).
- Додаткова фільтрація (where("count>2")).
- Дія collect(), яка ініціює обчислення.


Обґрунтування:
Spark виконує трансформації як ліниві операції. У цьому коді є лише одна дія collect(), 
яка запускає всі трансформації за один прохід. Таким чином, Spark створює 5 Jobs, 
які відповідають крокам обробки даних (включаючи зчитування, перерозподіл і обчислення результату).

Частина 2: 8 Jobs

Що відбувається:
У коді з'являється додаткова дія:
- Спочатку виконується nuek_processed.collect().
- Потім обчислюється ще одна трансформація (where("count>2")) і виконується повторна дія collect().

Обґрунтування:
При першому виклику nuek_processed.collect(), Spark обчислює всі попередні трансформації 
(repartition, where, groupBy, count) і завершує обчислення. Це завершується як 5 Jobs.

Потім виконується нова трансформація where("count>2"), яка додає ще 3 Jobs: 
один для зчитування даних, один для виконання фільтрації, і один для дії collect().
Загальна кількість Jobs: 5 (перший collect()) + 3 (додаткові операції) = 8 Jobs.

Відповідь не запитання: При додаванні проміжної дії collect() Spark змушений завершити 
обчислення поточного ланцюжка трансформацій і зберегти результат. 
Додаткові трансформації після цього створюють нові Jobs, оскільки Spark більше не оптимізує 
їх разом із попередніми обчисленнями.

Частина 3: 7 Jobs

Що відбувається:
- У цьому коді використовується cache() перед першим викликом collect().
- Після виклику cache() Spark обчислює всі попередні трансформації та зберігає результат у пам’яті.
- Далі використовуються кешовані дані для обчислення where("count>2") і дії collect().

Обґрунтування:
Завдяки кешуванню (cache()), Spark зберігає проміжні результати в пам'яті 
після першого обчислення. Це дозволяє уникнути повторного виконання трансформацій.

Кількість Jobs скорочується:
4 Jobs для обчислення даних і кешування.
3 Jobs для подальшої обробки даних і дії collect() з використанням кешу.

Загальна кількість Jobs: 4 (перше обчислення і кешування) + 3 (наступні операції) = 7 Jobs.